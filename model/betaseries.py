#!/usr/bin/env python
"""betaseries: script for computing beta-series regression on fMRI data
"""

from argparse import ArgumentParser, RawTextHelpFormatter
s = """Estimate betaseries using LS-S regression.

See Mumford et al. 2014 for details. 

Specify the base for a design generated by FEAT. For example, if you
have a .fsf file in mydesign.fsf, specify mydesign as the modelbase.

The trial regressors are assumed to be in your original EVs (as opposed
to the real EVs, which include for example temporal derivatives of the
original EVs). The trials to model are assumed to be the first ones listed.
For example, if 30 orig EVs are included in the model, and ntrials is set
to 20, then the last 10 EVs are assumed to be modeling things other than
the individual trials.

You may also specify confound regressors (defined in the fsf file under
'confoundev_files'), which will be included as regressors of no interest.

"""

parser = ArgumentParser(description="Estimate betaseries using LS-S regression (Mumford et al. 2014).")
parser.add_argument('modelbase', type=str,
                    help="path to model files, without file extension")
parser.add_argument('betadir', type=str,
                    help="path to directory in which to save betaseries image")
parser.add_argument('ntrials', type=int,
                    help="number of trials to be estimated")
parser.add_argument('-m', '--mask', type=str,
                    help="(optional) path to mask image, indicating included voxels")
args = parser.parse_args()

from mvpa2.misc.fsl.base import FslGLMDesign, read_fsl_design
from mvpa2.datasets.mri import fmri_dataset, map2nifti

import numpy as N
import scipy.stats
from scipy.stats.mstats import zscore
import os

fsffile = args.modelbase + '.fsf'
matfile = args.modelbase + '.mat'
betadir = args.betadir
ntrials = args.ntrials

good_evs = range(0,ntrials)

print("Loading design...")
design = read_fsl_design(fsffile)
desmat = FslGLMDesign(matfile)

ntp, nevs = desmat.mat.shape

# find input bold data
print("Loading data...")
bold = design['feat_files']
if not bold.endswith('.nii.gz'):
    bold += '.nii.gz'
if not os.path.exists(bold):
    raise IOError('BOLD file not found: {}'.format(bold))

if args.mask is not None:
    # user specified a mask
    mask = args.mask
    if not mask.endswith('.nii.gz'):
        mask += '.nii.gz'
    if not os.path.exists(mask):
        raise IOError('Mask file not found: {}'.format(mask))
    data = fmri_dataset(bold, mask=mask)
else:
    # load all voxels
    data = fmri_dataset(bold)

# design matrix
print("Creating design matrices...")
if design.has_key('confoundev_files'):
    conf_file = design['confoundev_files']
    print("Loading confound file {}...".format(conf_file))
    dm_nuisance = N.loadtxt(conf_file)
else:
    print("No confound file indicated. Including no confound regressors...")
    dm_nuisance = None
dm_extra = desmat.mat[:,ntrials:]

# create a beta-forming vector for each trial
beta_maker = N.zeros((ntrials, ntp))
for e in range(len(good_evs)):
    # trial of interest
    ev = good_evs[e]
    dm_toi = desmat.mat[:,ev,N.newaxis]

    # other trials
    other_good_evs = [x for x in good_evs if x != ev]
    dm_otherevs = desmat.mat[:,other_good_evs]
    dm_otherevs = N.sum(dm_otherevs[:,:,N.newaxis], 1)

    # put together the design matrix
    if dm_nuisance is not None:
        dm_full = N.hstack((dm_toi, dm_otherevs, dm_nuisance, dm_extra))
    else:
        dm_full = N.hstack((dm_toi, dm_otherevs, dm_extra))
    s = dm_full.shape
    dm_full = dm_full - N.kron(N.ones(s), N.mean(dm_full,0))[:s[0],:s[1]]
    dm_full = N.hstack((dm_full, N.ones((ntp,1))))

    # calculate beta-forming vector
    beta_maker_loop = N.linalg.pinv(dm_full)
    beta_maker[e,:] = beta_maker_loop[0,:]

print("Estimating model...")
# this uses Jeanette's trick of extracting the beta-forming vector for each
# trial and putting them together, which allows estimation for all trials
# at once
glm_res_full = N.dot(beta_maker, data.samples)

# map the data into images and save to betaseries directory
for e in range(len(glm_res_full)):
    outdata = zscore(glm_res_full[e])
    ni = map2nifti(data,data=outdata)
    ni.to_filename(os.path.join(betadir,
                                'ev{:03d}.nii.gz'.format(good_evs[e])))
